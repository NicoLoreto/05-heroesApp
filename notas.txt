
### ANGULAR MATERIAL ###

para usar angular material ingreso a la pagina
https://material.angular.io/ voy a guides y copio el comando de instalacion
lo ejecuto en la terminal
ng g m material

para los modulos de material design de angular
importados

### CARGA PERESOZA O LAZYLOAD ###

las paginas lazylooad son mas rapidas porque no cargan
modulos innecesario. es decir, si un usuario no esta autenticado
no cargaria ese modulo hasta que se autentifique

primero se crea un sistema de rutas

ng g m auth

el modulo auth es para hacer un autenticacion

tengo que generar un nuevo modulo que este al mismo
nivel que el auth.module

ng g m auth/authRouting --flat

en ese modulo tengo que crear rutas del misma manera
excepto que tendra path y children porque seran rutas hijas
el path va a ocupar un segmento, ej path: 'auth/'

como son rutas hijas se importan como RouterModule.forChild()
tmb debo exportar el RouterModule

luego necesito hacer que cuando alguien cargue
ese auth se cargue el modulo
entonces en la ruta principal defino el path auth y loadchilren
para que cargue el respectivo nombre.
hace una promesa hasta que cargan los hijos
y luego importa el modulo auth.module
porque alli estan definidos los componentes.

cuando alguien entre al path auth carga sus hijos
ese modulo hijo viene de auth modulecuando se cargueva a regresar el auth module


  {

    path: 'auth',
    loadChildren: () => import ('./auth/auth.module')
      .then(m => m.AuthModule)

  },

  las rutas hijas

  const routes: Routes = [
  {
    path: '',
    children:[

      {
        path: 'listado',
        component: ListadoComponent
      },

      {
        path: 'agregar',
        component: AgregarComponent
      },

      {
        path: 'editar/:id',
        component: AgregarComponent
      },

      {
        path: 'buscar',
        component: BuscarComponent
      },

      {
        path: ':id',
        component: HeroeComponent
      },

      {
        path: '**',
        redirectTo: 'listado'
      }
    ]
  }
]

el path aca va '' porque requerira el nombre del modulo
al que se esta refiriendo automaticamente. seria el 
equivalente

es necesario importar RouterModule.forChild(routes)
y exportar RouterModule
luego, importar las rutas hijas en el modulo del directorio
y luego requerir ese modulo desde las rutas principales


  {

    path: 'heroes',
    loadChildren: () => import ('./heroes/heroes.module').then(m => m.HeroesModule)

  },

### RUTAS ###

usaualmente se crean al mismo nivel que app.module. Dentro de app
las rutas son un modulo

ng g m appRouting --flat 

--flat es para que no cree un directorio y lo coloque en la raiz del proyecto

como en las rutas no necesito usar componentes con ngFor, etc. no necesito commonModule

para crear las rutas:
    se crea un constante de tipo
    const routes Routes [{
        path: '404',
        component: ErrorPageComponent
    }]

    luego se debe importar el modulo RouterModule y agregar .forRoot()
    para especificar que alli estarn las rutas principales, la 
    constante debe ir en el ().
    desp se tiene que exportar RouterModule para que este disponible entoda la app
    desp tengo que importarlo en app.module

<router-outlet></router-outlet> ira en el app.component.html
para decirle que cuando la ruta haga
match con la ruta en la que estoy la tome

### BACKEND RAPIDO ###

en npm json server ofrece un bakend sin configurar 
https://www.npmjs.com/package/json-server

instalar de forma global, se debe instalar desde administrador de usuario
npm install -g json-server

para levantar el server hay que ir a la carpeta que contiene el archivo y ejecutar
json-server --watch nombre del archivo

las imagenes van en app src assets

para hacer las peticiones al backend tengo que hacer un service para heroes
en una carpeta que llame services

cuando esta la propiedad

  @Injectable({
    providedIn: 'root'
  })

definida, no es necesario importa el servicio en un m

como son solicitudes http necesito importar common module, especificamente http client module de forma global

una vez esta importado de modo global puedo hacer la peticicion get desde el servicio

  export class HeroesService {

    constructor( private http : HttpClient) { }

    getHeroes(){
      return this.http.get('http://localhost:3000/heroes')
    }
  }

tengo que importar el modulo HttpClien para usar el servicio

lo voy a consumir en distintos componentes, empezando por listado
por lo cual se inyecta el servicio en el componente.ts

export class ListadoComponent {

  constructor(private heroesService: HeroesService){}

}

en ngOnInit hago uso de el suscribiendome al metodo
con subscribe el metodo se dispara

 ngOnInit(): void {

    this.heroesService.getHeroes()
      .subscribe (resp => console.log (resp))

  }

luego tengo que hacer una interface para definir el tipado de la respuesta que recibire del servicio
para eso se usa quicktype.io
uso el tipo JSON, tiene que estar en interface only y me crea el tipado
creo una carpeta interfaces en heroes y dentro heroes.interface.ts

luego debo decirle al service que tipo de
dato va a recibir

  getHeroes(): Observable<Heroe[]>{
    return this.http.get<Heroe[]>('http://localhost:3000/heroes')
  }

para mostrar los heroes en el html necesito
hacer una propiedad en el component que seran
del tipo Heroe[] y especificar en el ngOnInit
que la respuesta que voy a recibir va a ser igual a 
esa propiedad.
PRIMERO VA EL THIS.HEROES Y DESP LA RESPUESTA

  heroes: Heroe[] = [];
  
  ngOnInit(): void {

    this.heroesService.getHeroes()
      .subscribe (resp => {
        this.heroes = resp
      })

  }

  ### SPINNER ###

  un spiner es el circulo que gira cuando carga la pagina, lo consigo en angular material


  ### SWITCH MAP ###

  switch map sirve para interrumpir un observable.
  es un interruptor. Recibe un observable y regresa otro.
  switchMap es un operador que recibe los parámetros del primer observable y los puedes utilizar para retornar otro observable utilizando esos params si es el caso.
  Es muy común usar el operador cuando tenemos observables en cadena, que se necesita se ejecute uno y luego otro. De esta manera, obtener solo una 1 respuesta en el subscribe.
  Si únicamente tienes un observable, simplemente utiliza subscribe y ya. 
  pipe es para especificar los operadores
  que actuaran sobre params. 

  ### ENDPOINT ###

  para saber el endpoint que tengo que llamar puedo
  usar postman usando querys en params. Por ej http://localhost:3000/heroes?q=super trairia todo
  lo que diga super.
  limito la cantidad de resultado con &_limit=5, por ej.

  POST = Crear un recurso entero
    - Para hacer una solicitud post tengo que crear en el servicio el endpoint al que voy a dirigirme

      agregarHeroe(heroe: Heroe): Observable<Heroe>{
        return this.http.post<Heroe>(`${this.baseUrl}/heroes`, heroe)
    }

    La data que tengo que grabar se manda como segundo argumento, en este caso heroe, o sea el body, desp
    del endpoint

  PUT = Actualiza todo el objeto
  PATCH = Actuaiza parcialmente, por ej el id.
    - para hacer un cambio parcial puedo hacerlo, desde postman, pongo endpoint patch, voy a body,
    voy a raw, pongo tipo json y escribo el json que quiero cambiar, hago el send y cambio la propiedad.

    actualizarHeroe(heroe: Heroe): Observable<Heroe>{
      return this.http.patch<Heroe>(`${this.baseUrl}/heroes/${heroe.id}`, heroe)
    }

  DELETE = Elimina el objeto
    - para delete tengo que llamar a un id, y esperar un valor booleano, porque si el id no existe me devolveria
    un 404. Para ese error puedo usar un pipe catchError. 
     "of" se utiliza aquí para crear un observable que emite "false" en caso de error, para que el flujo de 
     datos no se detenga completamente en caso de que ocurra un error. En cambio, el observable emitirá el 
     valor predeterminado "false" y permitirá que el flujo de datos continúe. . Si no hay error va a devolver
     la resp con map

      eliminarHeroe(id: string): Observable<boolean>{
        return this.http.delete(`${this.baseUrl}/heroes/${id}`)
      .pipe(
        catchError(err=> of(false)),
        map(resp => (true))
    )
  }

  Estas solicitudes generalmente van en servicios

  